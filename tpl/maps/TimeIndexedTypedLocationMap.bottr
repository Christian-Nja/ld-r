@prefix rdf:	    <http://www.w3.org/1999/02/22-rdf-syntax-ns#> . 
@prefix rdfs:	    <http://www.w3.org/2000/01/rdf-schema#> . 
@prefix owl:	    <http://www.w3.org/2002/07/owl#> . 
@prefix xsd:	    <http://www.w3.org/2001/XMLSchema#> . 
@prefix foaf:	    <http://xmlns.com/foaf/0.1/> . 
@prefix dbp:    	<http://dbpedia.org/ontology/> . 
@prefix ex:         <http://example.com/ns#> . 
@prefix ottr:   	<http://ns.ottr.xyz/0.4/> . 
@prefix ax:	        <http://tpl.ottr.xyz/owl/axiom/0.1/> . 
@prefix rstr:   	<http://tpl.ottr.xyz/owl/restriction/0.1/> .
@prefix a-dd:       <https://w3id.org/arco/ontology/denotative-description/> .
@prefix odp-tpl:    <http://www.ontologydesignpatterns.org/tpl#> .
@prefix a-loc:      <https://w3id.org/arco/ontology/location/> .
@prefix tiapit:     <https://w3id.org/italia/onto/TI/> .
@prefix arco:        <https://w3id.org/arco/ontology/arco/> .

[] a ottr:InstanceMap ;
  ottr:source 
      [ a ottr:SPARQLEndpointSource ; 
        ottr:sourceURL "https://dati.beniculturali.it/sparql" ] ;
  ottr:query """

             SELECT DISTINCT 
                            ?cProp               
                            ?tITL
                            ?timeInterval
                            ?startDate
                            ?endDate
                            ?date
                            ?locationType
                               # we hack instance URI as UUID() doesn't work in virtuoso => it's new ns + other resource UUID
                            (URI(CONCAT ("https://w3id.org/arco/resource/TimeIndexedTypedLocationPattern", STRAFTER(STR(?tITL), "https://w3id.org/arco/resource/TimeIndexedTypedLocation"))) as ?instanceIRI)
                            ?instanceType
             WHERE
                   {
                          ?cProp a-loc:hasTimeIndexedTypedLocation ?tITL .
                          ?cProp a arco:CulturalProperty .
                          ?tITL  a  a-loc:TimeIndexedTypedLocation .
                          OPTIONAL {
                           ?tITL tiapit:atTime ?timeInterval .           # DATA MISSING IN KG
                           ?timeInterval a tiapit:TimeInterval .         # DATA MISSING IN KG
                           ?timeInterval tiapit:hasStartDate ?startDate . # DATA MISSING IN KG
                           ?timeInterval tiapit:hasEndDate ?endDate    .  # DATA MISSING IN KG
                           ?timeInterval tiapit:hasDate ?date .
                          }
                          ?tITL a-loc:hasLocationType ?locationType .
                       OPTIONAL {?patternInstanceUnboundable a rdf:PatternInstanceHackToAssignType . }
                       BIND ( IF (BOUND  (?patternInstanceUnboundable), a-loc:time-indexed-typed-location, a-loc:time-indexed-typed-location )  as ?instanceType  ) .
                   }
             LIMIT 200
""";
  ottr:template odp-tpl:TimeIndexedTypedLocation ;
  ottr:argumentMaps (
    [  ottr:type (rdf:List ottr:IRI);
       ottr:translationSettings [ ottr:listSep ";"]  ## ?cProp <= should be list of one value
    ]   
    [ ottr:type ottr:IRI ]   ## ?tITL
    [ ottr:type ottr:IRI ]   ## ?timeInterval <= null
    [ ottr:type ottr:IRI ]   ## ?startDate    <= null                 
    [ ottr:type ottr:IRI ]   ## ?endDate      <= null 
    [ ottr:type ottr:IRI ]   ## ?date         <= null                                 
    [ ottr:type ottr:IRI ]   ## ?locationType 
    [ ottr:type ottr:IRI ]   ## ?instanceIRI
    [ ottr:type ottr:IRI ]   ## ?instanceType
  ) .

```
Collection(ottr:IRI ?collection, List<ottr:IRI> ?members, ?patternInstance) :: {
    ListBelongsToPatternInstance(?collection, ?patternInstance),
    ListBelongsToPatternInstance(?members, ?patternInstance),
    cross
      |  ottr:Triple(?collection, :hasMember, ++?members)
}

ListBelongsToPatternInstance(List<ottr:IRI> ?nodes, ottr:IRI ?patternInstance) :: {
    cross
      |  ottr:Triple(++?nodes, opla:belongsToPatternInstance, ?patternInstance)
}
```
